---
title: "Projet S9"
author: "Adrien Faissat, Guillaume Schmit, Omar Himych, Morgane Roy"
date: "03/03/2022"
output:
  html_document:
    toc: yes
    toc_depth: 4
    number_sections: yes
---

```{r setup, include=FALSE}
library(readr)
library(ggplot2)
library(lubridate)
library(dplyr)
library(ReIns)
library(extRemes)
library(evd)

# Setup of options for the rmarkdown document
knitr::opts_chunk$set(echo = TRUE, # By default, codes are shown
                      warning = FALSE, # Warnings are not printed
                      message = FALSE, # Messages are not printed
                      out.width = "90%",
                      fig.align = 'center') # Codes results are cached into a 
# dedicated _cache directory which should be ignored by git (and emptied regularly)

## https://bookdown.org/yihui/rmarkdown/markdown-syntax.html pour des tips

```

# Introdution

## IntÃ©rÃªt gÃ©nÃ©ral des indices
## Types d'indices

# Indices Ã©tudiÃ©s  {.tabset}


## Fosberg Fire Weather Index (FFWI)

## FWI Canadien

## Angstrom Index

## MacArthur Grassland Mark 5 Index


# Discussion comparative des formules

## Description des Variables d'entrÃ©e

L'indice feu-météorologique de Fosberg (The Fosberg Fire Weather Index) est un indice pour estimer le danger d'incendie développé par Fosberg (1978). Il est basé sur la teneur en humidité à l'équilibre (Equilibrium Moisture Content) et la vitesse du vent (Wind speed), et nécessite des observations horaires de la température, de l'humidité relative de l'air et de la vitesse du vent comme données d'entrée.

Il a été conçu pour évaluer l'impact des variations météorologiques à petite échelle et à court terme sur le potentiel d'incendie et est très sensible aux changements de l'humidité du combustible fin.

L'indice FFWI est corrélé avec l'occurrence des incendies dans le nord-est et le sud-ouest des États-Unis par construction.

## Statique vs Dynamique

L'indice FFWI est statique puisque son calcul n'est pas basé sur les valeurs précédentes et aucune initialisation est nécessaire pour faire le calcul. En effet, nous avons besoin seulement de la valeur horaire des :
H : Humidité de l'aire en pourcentage
U : la vitesse de vent en mph
T : la température en °F
En revanche, le calcul se base sur des sous fonctions comme EMC.

## Ã‰chelles temporelles

# ImplÃ©mentation des calculs {.tabset}

Nous commenÃ§ons par exploiter les donnÃ©es recueillies par la station de Salon-de-Provence.
Nous avons Ã©galement utilisÃ© la base de donnÃ©es en ligne PromÃ©thÃ©e afin de recueillir la totalitÃ© des incendies ayant eu lieu sur la pÃ©riode Ã©tudiÃ©e dans le dÃ©partement. Cela nous permettra de confronter les indices avec la rÃ©alitÃ©.   

```{r data_loading, warning=FALSE, message=FALSE, cache=TRUE}
RR_2000_2021 <- read_delim("C:/Users/rachid/Desktop/Projet_Option/RR 2000-2021.csv", 
                           delim = ";", escape_double = FALSE, trim_ws = TRUE)
#View(RR_2000_2021)

RR_81_99 <- read_delim("C:/Users/rachid/Desktop/Projet_Option/RR 81-99.csv", 
                       delim = ";", escape_double = FALSE, trim_ws = TRUE)
#View(RR_81_99)

# Le vent

VT_81_99 <- read_delim("C:/Users/rachid/Desktop/Projet_Option/VT 81-99.csv", 
                       delim = ";", escape_double = FALSE, trim_ws = TRUE)
#View(VT_81_99)


VT_2000_2021 <- read_delim("C:/Users/rachid/Desktop/Projet_Option/VT 2000-2021.csv", 
                           delim = ";", escape_double = FALSE, trim_ws = TRUE)
#View(VT_2000_2021)

# La tempÃ©rature 

T_81_99 <- read_delim("C:/Users/rachid/Desktop/Projet_Option/T 81-99.csv", 
                      delim = ";", escape_double = FALSE, trim_ws = TRUE)
#View(T_81_99)

T_2000_2021 <- read_delim("C:/Users/rachid/Desktop/Projet_Option/T 2000-2021.csv", 
                          delim = ";", escape_double = FALSE, trim_ws = TRUE)
#View(T_2000_2021)

# l'humiditÃ© 

U_81_99 <- read_delim("C:/Users/rachid/Desktop/Projet_Option/U 81-99.csv", 
                      delim = ";", escape_double = FALSE, trim_ws = TRUE)
#View(U_81_99)


U_2000_2021 <- read_delim("C:/Users/rachid/Desktop/Projet_Option/U 2000-2021.csv", 
                          delim = ";", escape_double = FALSE, trim_ws = TRUE)

```

## Fosberg Fire Weather Index (FFWI) 

### Concaténation des données 

on va tout d'abord combiner les données pour avoir une seul base  donnée de 1981 à 2021

```{r FFwi}

U_complet<- rbind(U_81_99,U_2000_2021)
 

VT_complet<- rbind(VT_81_99,VT_2000_2021)

T_complet<- rbind(T_81_99,T_2000_2021)

RR_complet<- rbind(RR_81_99,RR_2000_2021)

length(RR_complet$RR)
length(T_complet$T)

```

###  Gestion des valeurs manquants 

Cette partie consiste à gérer les valeurs NAN dans notre base données.nous essyons de savoir le nombre exacte des valeurs manquantes dans chaque colonne.

```{r FFWI}

263232-length(na.omit(T_complet$T))

263232-length(na.omit(VT_complet$VT))

263232-length(na.omit(U_complet$U))

263232-length(na.omit(RR_complet$RR))

```

Ensuite, nous allons récupérer la moyen de chaque variable météorologique qui sert à remplacer les valeurs NAN

```{r FFWI}

mean(na.omit(RR_complet$RR))

mean(na.omit(T_complet$T))

mean(na.omit(VT_complet$VT))

mean(na.omit(U_complet$U))


```

Alors, on remplace les NAN par la moyen et on remarque que effectivement y plus de valeurs manquantes puisque la longueur est  :

```{r FFWI}

RR_complet[is.na(RR_complet)]<-0.06693427
T_complet[is.na(T_complet)]<-14.59049
VT_complet[is.na(VT_complet)]<-13.60234
U_complet[is.na(U_complet)]<-67.76571

length(na.omit(RR_complet$RR))
length(na.omit(T_complet$T))
length(na.omit(VT_complet$VT)) 
length(na.omit(U_complet$U))

```


### Calcul de FFWI :

le calcul des indices se fait par les formules ci dessus :
![EMC formule.](C:/Users/rachid/Desktop/Projet_Option/Dossier R/Project_S9/Images/Formule1.png)


#### EMC :

```{r FFWI}

EMC <- function(H,t) {
  
  
  if (H < 10 )  {
    resu <- 0.03229 + 0.281073*H - 0.000578*H*t
    
  } 
  
  else { 
    if (H >= 50) {
    resu <- 21.0606 + 0.005565*H*H - 0.00035*H*t - 0.483199*H
    
    } 
  
   else {
    resu <- 2.22749 + 0.160107*H - 0.01478*t
  } }
  
  return(resu)
}

```

#### Nu :

![Nu formule.](C:/Users/rachid/Desktop/Projet_Option/Dossier R/Project_S9/Images/Formule3.png)

```{r FFWI}

nu <- function(H,t){
  
  resu2=1 -2*((EMC(H,t))/30) + 1.5*((EMC(H,t))/30)*((EMC(H,t))/30) + 0.5*((EMC(H,t))/30)*((EMC(H,t))/30)*((EMC(H,t))/30)
  
  return(resu2)
}


```

#### FFWI :

![FFWI formule.](C:/Users/rachid/Desktop/Projet_Option/Dossier R/Project_S9/Images/Formule2.png)

```{r FFWI}

FFWI<- function(H,t,V){return((nu(H,t)*sqrt(1+V*V))/0.3002)}

FFWI(U_complet$U[length(U_complet)],T_complet$T[length(T_complet)],VT_complet$VT[length(VT_complet)])
```
Donc, la dernière valeur de l'indice c'est bien 6.318553.


```{r FFWI}
FFwi_values<-cbind(T_complet)
names(FFwi_values)[names(FFwi_values) == "T"] <- "FFwi"
 
FFwi_values$FFwi[1]<-0
FFwi_values$FFwi[2]<-0



for (i in 1:length(FFwi_values$FFwi))  {
    
    FFwi_values$FFwi[i]<- FFWI(U_complet$U[i],T_complet$T[i],VT_complet$VT[i])
 
  }


```


## FWI Canadien

## Angstrom Index

```{r angstrom_implementation, cache=TRUE}
T_13h <- rbind(T_81_99[T_81_99$HEURE == 13,],T_2000_2021[T_2000_2021$HEURE == 13,])
U_13h <- rbind(U_81_99[U_81_99$HEURE == 13,],U_2000_2021[U_2000_2021$HEURE == 13,])
  
Angstrom_Index <- data.frame(matrix(ncol=7,nrow=nrow(T_13h)))
colnames(Angstrom_Index) <- c("DATE", "AN", "MOIS", "JOUR","ANGSTROM_INDEX", "U", "T")

for(i in 1:nrow(Angstrom_Index))
{
  ligne_humidite <- U_13h[i,]
  ligne_temperature <- T_13h[T_13h$AN == ligne_humidite$AN & T_13h$MOIS == ligne_humidite$MOIS & T_13h$JOUR == ligne_humidite$JOUR,]
  
  index <- (ligne_humidite$U / 20) + (27 - ligne_temperature$T)/10
  
  Angstrom_Index[i,] <- c(as.Date(gsub(" ", "", paste(ligne_humidite$JOUR,"/",ligne_humidite$MOIS,"/",ligne_humidite$AN)),format="%d/%m/%Y", origin="1970-01-01"),ligne_humidite$AN, ligne_humidite$MOIS, ligne_humidite$JOUR, index, ligne_humidite$U, ligne_temperature$T)

}


nb_iteration = nrow(Angstrom_Index)
Index_Summer <- data.frame(DATE=numeric(), AN=numeric(), MOIS=numeric(), JOUR=numeric(),ANGSTROM_INDEX=numeric(), U = numeric(), T=numeric(), stringsAsFactors=FALSE)

for (i in 1:nb_iteration){
  month <- month(as.Date(Angstrom_Index[i,]$DATE, origin="1970-01-01"))
  if(month == 6 || month == 7 || month == 8){
      Index_Summer[nrow(Index_Summer)+1,] <- Angstrom_Index[i,]
  }
}
  
```

## MacArthur Grassland Mark 5 Index




# Analyse des sÃ©ries d'indice {.tabset}

Nous mettons ici une fonction qui nous aidera pour les corrÃ©lations extrÃªmales entre sÃ©ries :

```{r}
extremal_correlation_input_output <- function(input,output, quant){
  u1 = quantile(output, quant, na.rm = TRUE)
  u2 = quantile(input, quant, na.rm = TRUE)
  xi.est.quantile = sum(output > u1 & input > u2)/sum(output > u1)
  
  xi.est.quantile
}

```


## Fosberg Fire Weather Index (FFWI)

### Analyse gÃ©nÃ©rale :
Nous allons effectuer une analyse statistique pour notre série temporelle. La fonction summary permet d'avoir toutes les valeurs importantes : Max, min, moyen, médian, 25% quantile, 75% quantile. Ensuite nous traçons la série sur tout horizon qui montre l'effet de saisonnalité mais apparemment il n'y a pas de tendance. En plus, l'histogramme ci-dessous illustre la distribution de notre indice qui bien asymétrique.  
```{r FFWI}
summary(FFwi_values)

year2plot = 2019
plot(FFwi_values$FFwi[FFwi_values$AN == year2plot], type = "h", xlab='Jours', ylab='FFWI index', main='Evolution temporelle de FFWI entre 1981 à 2021' )


hist(FFwi_values$FFwi, freq=F, col='green', breaks=35, xlab='les valeurs de FFWI', main='La distribution de FFWI')
lines(density(FFwi_values$FFwi), col='red',lwd=3)

```

Dans cette partie nous utilisons la fonction acf pour calculer les coefficients de autocorrélations. La première figure montre la forte corrélation entre les observations puisque les lages se coupent pas rapidement. La deuxième figure, quand nous avons augmenté le nombre des lages, l'effet de saisonnalité est clair.

```{r  FFWI}

acf(FFwi_values$FFwi, na.action = na.pass, lag.max = 18, main="Auto-corrÃ©lation temporelle de l'indice")

acf(FFwi_values$FFwi, na.action = na.pass, lag.max = 100, main="Auto-corrÃ©lation temporelle de l'indice")


```

### FFWI_13 et les incendies :

Ici, nous récupérons en gros que les valeurs des indices à 13h pour être compatibles avec Angstrom.
```{r}

##  réorganise FFWI 13h réorganiser

T_13h <- T_complet[T_complet$HEURE == 13,]
U_13h <- U_complet[U_complet$HEURE == 13,]

FFWI_Index_13 <<- data.frame(matrix(ncol=2,nrow=10968))

colnames(FFWI_Index_13) <- c("DATE", "FFWI_INDEX")

#View(FFWI_Index_13)

for(i in 1:10968){
  
  ligne_humidite <- U_13h[i,]

  FFWI_Index_13[i,] <- c(as.Date(gsub(" ", "", paste(ligne_humidite$JOUR,"/",ligne_humidite$MOIS,"/",ligne_humidite$AN)),format="%d/%m/%Y", origin="1970-01-01"), FFwi_values$FFwi[i])
  
}
```

on gère les dates pour chaque variable
```{r}



T_date<<- data.frame(matrix(ncol=2,nrow=8760))

colnames(T_date) <- c("DATE", "T")


for(i in 254472:263232){
  
  ligne_humidite <-T_complet[i,]

  T_date[i,] <- c(as.Date(gsub(" ", "", paste(ligne_humidite$JOUR,"/",ligne_humidite$MOIS,"/",ligne_humidite$AN)),format="%d/%m/%Y", origin="1970-01-01"), T_complet$T[i])
  
}
```


```{r}


U_date<<- data.frame(matrix(ncol=2,nrow=8760))

colnames(U_date) <- c("DATE", "U")


for(i in 254472:263232){
  
  ligne_humidite <-U_complet[i,]

  U_date[i,] <- c(as.Date(gsub(" ", "", paste(ligne_humidite$JOUR,"/",ligne_humidite$MOIS,"/",ligne_humidite$AN)),format="%d/%m/%Y", origin="1970-01-01"), U_complet$T[i])
  
}
```


```{r}



VT_date<<- data.frame(matrix(ncol=2,nrow=8760))

colnames(VT_date) <- c("DATE", "VT")


for(i in 254472:263232){
  
  ligne_humidite <- VT_complet[i,]

  VT_date[i,] <- c(as.Date(gsub(" ", "", paste(ligne_humidite$JOUR,"/",ligne_humidite$MOIS,"/",ligne_humidite$AN)),format="%d/%m/%Y", origin="1970-01-01"), VT_complet$T[i])
  
}
```

Cette partie est dédié à superposer les incendies (point noir) qui ont lieu à Avignon avec les valeurs de notre indice. Nous constatons que l'indice ne décrit pas parfaitement ces incendies puisque les points noirs sont distribués sans aucune particularité par rapport à FFWI. Nous pouvons explique ça par le fait que FFWI est compatible avec les régions nord-est et le sud-ouest des États-Unis.

```{r}
########


Incendie_81_2021 <- read_delim("C:/Users/rachid/Desktop/Projet_Option/liste_incendies_91_2021.csv")



seuil_incendie <- 10000 #m2 seuil pour les incendies

date_debut <- as.Date("01/01/2000","%d/%m/%Y")
date_fin <- as.Date("22/12/2020","%d/%m/%Y")

nb_iteration = nrow(FFWI_Index_13)
Index_Summer <- data.frame(DATE=numeric(), FFWI_Index_13=numeric(), stringsAsFactors=FALSE)

for (i in 1:nb_iteration){
  
  month <- month(as.Date(FFWI_Index_13[i,]$DATE, origin="1970-01-01"))
  if(month == 6 || month == 7 || month == 8){
    Index_Summer[nrow(Index_Summer)+1,] <- FFWI_Index_13[i,]
  }
  
}


########

Incendies_filtered <- Incendie_81_2021[Incendie_81_2021$`Surface parcourue (m2)` >= seuil_incendie,]


graph_ffwi <- FFWI_Index_13 %>% filter(between(as.Date(DATE,origin="1970-01-01"), date_debut,date_fin))

graph_T <- T_date %>% filter(between(as.Date(DATE,origin="1970-01-01"), date_debut,date_fin))

graph_U <- U_date %>% filter(between(as.Date(DATE,origin="1970-01-01"), date_debut,date_fin))

graph_VT <- VT_date %>% filter(between(as.Date(DATE,origin="1970-01-01"), date_debut,date_fin))

graph_summer_FFwi_index <- Index_Summer %>% filter(between(as.Date(DATE,origin="1970-01-01"), date_debut,date_fin))

length(graph_ffwi$FFWI_INDEX)
length(FFWI_Index_13$FFWI_INDEX)

```



```{r}

### Plotting all dates within chosen range ###

ggplot(data = graph_ffwi,
       mapping = aes(x = as.Date(DATE, origin="1970-01-01"), y =FFWI_INDEX, color = FFWI_INDEX, xmin = date_debut,xmax=date_fin)) +
  geom_point() +
  scale_color_gradient(guide="none", low="red", high="green") +
  labs(x = "Date", y = "FFWI Index") +
  geom_point(data = graph_ffwi %>% filter(as.Date(DATE, origin="1970-01-01") %in% as.Date.character(Incendies_filtered$Alerte,format="%d/%m/%Y %H:%M", origin="1970-01-01")),
             pch=16, size=2, colour="black")

### Plotting all summer dates within chosen range ###

ggplot(data = graph_summer_FFwi_index,
       mapping = aes(x = as.Date(DATE, origin="1970-01-01"), y = FFWI_Index_13, color = FFWI_Index_13, xmin = date_debut,xmax=date_fin)) +
  geom_point() +
  scale_color_gradient(guide="none", low="red", high="green") +
  labs(x = "Date", y = "FFWI Index") +
  geom_point(data = graph_summer_FFwi_index %>% filter(as.Date(DATE, origin="1970-01-01") %in% as.Date.character(Incendies_filtered$Alerte,format="%d/%m/%Y %H:%M", origin="1970-01-01")),
             pch=16, size=2, colour="black")

```

L'indice ne décrit pas pafaitement les incendies.

### Tail index

```{r}

moment_data <- na.omit(FFwi_values)
moment_data$FFwi <- moment_data$FFwi *-1
min_moment <- min(moment_data$FFwi)
moment_data$FFwi <- moment_data$FFwi - min_moment +1
moment_data <- moment_data[moment_data$FFwi > 0,]

MFFWI <- Moment(moment_data$FFwi, logk = FALSE, plot = TRUE, main = "Estimation de moment pour FFWI")

plot(MFFWI$k[MFFWI$k %in% 25:500], MFFWI$gamma[MFFWI$k %in% 25:500], main="", xlab="Nombre des evenements extremes ", ylab="Tail index")

```

### Auto-corrÃ©lation extrÃªmale
Nous supposons aque des observations non-indépendantes. L'autocorrélation caractérise les probabilités de co-occurrence de valeurs élevée au décalage temporel h.

```{r}

###

prob = .95 # la probablité correspondante au seuil u
tmp1 = atdf(as.ts(FFwi_values$FFwi), u = prob, plot = FALSE, lag.max = 40, type = "rho")
par(mar = c(5, 5, .5, .5), cex.lab = 2, cex.axis = 2, lwd = 2, cex = 1)
plot(tmp1, main = "", xlab = "h", ylab = expression(chi(u,h)))
lines(c(0, 100), rep(1-prob,2), lwd = 2, lty = 2, col = "red")

```
Nous pouvons améliorer le résultat en filtrant les données par saison (été) pour compenser  l'effet des saisonnalité.

```{r}

###

moment_summer <- na.omit(Index_Summer)

prob = .95 # probability for quantile to be used as threshold
tmp2 = atdf(as.ts(moment_summer$FFWI_Index_13), u = prob, plot = FALSE, lag.max = 21, type = "rho")
par(mar = c(5, 5, .5, .5), cex.lab = 2, cex.axis = 2, lwd = 2, cex = 1)
plot(tmp2, main = "", xlab = "h", ylab = expression(chi(u,h)))
lines(c(0, 100), rep(1-prob,2), lwd = 2, lty = 2, col = "red")

```
 Nous constatons que l'effet de saisonalité est disparu.
 
### Estimer les valeurs  extermales dans FFWI:

```{r}

extract_function = function(vec, nr_of_na_allowed = 60){
  if(sum(is.na(vec)) > nr_of_na_allowed){
    return(NA)
  }else{
    return(max(vec, na.rm = TRUE))
  }
}

# yearly humidity  maxima ####

tmpU = aggregate(U_complet$U, by = list(year = U_complet$AN), FUN = extract_function)
#view(tmp)
mean(is.na(tmpU$x)) # proportion of years with too many NA data

obsU = tmpU$x

#yearl temperature maxima ####

tmpT = aggregate(T_complet$T, by = list(year = T_complet$AN), FUN = extract_function)
#view(tmp)
mean(is.na(tmpT$x)) # proportion of years with too many NA data
# observations of maxima
obsT = tmpT$x

# yearly Wind maxima ####

tmpVT = aggregate(VT_complet$VT, by = list(year = VT_complet$AN), FUN = extract_function)
#view(tmp)
mean(is.na(tmpVT$x)) # proportion of years with too many NA data
# observations of maxima
obsVT = tmpVT$x

# yearly ffwi maxima ####

tmp = aggregate(FFwi_values$FFwi, by = list(year = FFwi_values$AN), FUN = extract_function)
#view(tmp)
mean(is.na(tmp$x)) # proportion of years with too many NA data
# observations of maxima
obs = tmp$x


par(mfrow=c(2,2))

plot(tmp$year, tmp$x, type = "b", pch = 19, xlab = "Year", ylab = "Maximum Indice")
plot(tmpVT$year, tmpVT$x, type = "b", pch = 19, xlab = "Year", ylab = "Maximum vent")
plot(tmpT$year, tmpT$x, type = "b", pch = 19, xlab = "Year", ylab = "Maximum Température")
plot(tmpU$year, tmpU$x, type = "b", pch = 19, xlab = "Year", ylab = "Maximum Humidité")


# fit a stationary model to ffwi:

fit = fevd(obs, type = "GEV", method = "MLE", period.basis = "year", use.phi = TRUE)
summary(fit)
plot(fit)
plot(fit, type = "qq", main = "")

```

Nous avons essayé d'extraire les valeurs maximales avec la méthode Block maxima pour notre indice et puis estimer les paramètres de GEV.

Nous constatons que les valeurs maximales de vent sont très cohérentes avec de notre indice. ce qui montre la grande sensibilité du l'indice par le vent.

QQ plot montre que notre modèle emprique est compatible avec le modèle  théorique avec un AIC 249.4499.


### Analyse extrÃªmale entre les sÃ©ries
Ici on compare entre les indices  Angstrom et FFWI.

#### Estimation empirque de  "tail correlation" xi :

On constate bien que la tail correlation est reste égale à 0 presque pour tout les valeures de quantile. On peut donc supposer qu'il y a de dépendance asymptotique entre les deux indices.

```{r}
chiplot(cbind(FFWI_Index_13$FFWI_INDEX,Angstrom_Index$ANGSTROM_INDEX ), qlim = c(0.8, .9), xlim = c(0.8, .9), which = 1)

```
## FWI Canadien

### Tail index 
### Auto-corrÃ©lation extrÃªmale
### CorrÃ©lation extrÃªmale entre les sÃ©ries

## Angstrom Index

### Analyse gÃ©nÃ©rale

```` {r angstrom_general_analysis, warning=FALSE}

acf(Angstrom_Index$ANGSTROM_INDEX, na.action = na.pass, lag.max = 21, main="Auto-corrÃ©lation temporelle de l'indice")

acf(Index_Summer$ANGSTROM_INDEX, na.action = na.pass, lag.max = 21, main ="Auto-corrÃ©lation temporelle de l'indice pris sur les pÃ©riodes estivales")

````

On constate que l'auto-corrÃ©lation est plus Ã©levÃ©e quand on considÃ¨re les pÃ©riodes non-estivales, ce qui n'est pas particuliÃ¨rement Ã©tonnant : il paraÃ®t cohÃ©rent que les pÃ©riodes moins chaudes et moins sÃ¨ches soient moins propices Ã  des valeurs extrÃªmes de risque d'incendie, et donc une certaine corrÃ©lation entre les jours "non-incendie".

````{r}
seuil_incendie <- 10000 #m2 seuil pour les incendies

date_debut <- as.Date("01/06/2000","%d/%m/%Y")
date_fin <- as.Date("22/12/2020","%d/%m/%Y")

########

Incendies_filtered <- Incendie_81_2021[Incendie_81_2021$`Surface parcourue (m2)` >= seuil_incendie,]


graph_angstrom_index <- Angstrom_Index %>% filter(between(as.Date(DATE,origin="1970-01-01"), date_debut,date_fin))

graph_summer_angstrom_index <- Index_Summer %>% filter(between(as.Date(DATE,origin="1970-01-01"), date_debut,date_fin))


### Plotting all dates within chosen range ###

ggplot(data = graph_angstrom_index,
       mapping = aes(x = as.Date(DATE, origin="1970-01-01"), y = ANGSTROM_INDEX, color = ANGSTROM_INDEX, xmin = date_debut,xmax=date_fin)) +
  geom_point() +
  scale_color_gradient(guide="none", low="red", high="green") +
  labs(x = "Date", y = "Angstrom Index") +
  geom_point(data = graph_angstrom_index %>% filter(as.Date(DATE, origin="1970-01-01") %in% as.Date.character(Incendies_filtered$Alerte,format="%d/%m/%Y %H:%M", origin="1970-01-01")),
             pch=16, size=2, colour="black")

### Plotting all summer dates within chosen range ###

ggplot(data = graph_summer_angstrom_index,
       mapping = aes(x = as.Date(DATE, origin="1970-01-01"), y = ANGSTROM_INDEX, color = ANGSTROM_INDEX, xmin = date_debut,xmax=date_fin)) +
  geom_point() +
  scale_color_gradient(guide="none", low="red", high="green") +
  labs(x = "Date", y = "Angstrom Index") +
  geom_point(data = graph_summer_angstrom_index %>% filter(as.Date(DATE, origin="1970-01-01") %in% as.Date.character(Incendies_filtered$Alerte,format="%d/%m/%Y %H:%M", origin="1970-01-01")),
             pch=16, size=2, colour="black")


````

On constate que la majoritÃ© des gros incendies (> 10000 mÂ²) ont bien lieu lors des pÃ©riodes oÃ¹ le risque prÃ©vu par l'indice Angstrom est est Ã©levÃ© (donc valeur de l'indice faible).

### Tail index 

```` {r}

moment_data <- na.omit(Angstrom_Index)
moment_data$ANGSTROM_INDEX <- moment_data$ANGSTROM_INDEX *-1
min_moment <- min(moment_data$ANGSTROM_INDEX)
moment_data$ANGSTROM_INDEX <- moment_data$ANGSTROM_INDEX - min_moment +1
moment_data <- moment_data[moment_data$ANGSTROM_INDEX > 0,]
M <- Moment(moment_data$ANGSTROM_INDEX, logk = FALSE, plot = TRUE, main = "Moment estimate of the Angstrom Index")

plot(M$k[M$k %in% 25:500], M$gamma[M$k %in% 25:500], main="", xlab="Number of extreme events", ylab="Tail index")

````

### Auto-corrÃ©lation extrÃªmale



````{r}
###

moment_summer <- na.omit(Index_Summer)
prob = .95 # probability for quantile to be used as threshold
tmp = atdf(as.ts(moment_summer$ANGSTROM_INDEX), u = prob, plot = FALSE, lag.max = 21, type = "rho")
par(mar = c(5, 5, .5, .5), cex.lab = 2, cex.axis = 2, lwd = 2, cex = 1)
plot(tmp, main = "", xlab = "h", ylab = expression(chi(u,h)))
lines(c(0, 100), rep(1-prob,2), lwd = 2, lty = 2, col = "red")

````

### CorrÃ©lation extrÃªmale entre les sÃ©ries






## MacArthur Grassland Mark 5 Index

### Tail index 
### Auto-corrÃ©lation extrÃªmale
### CorrÃ©lation extrÃªmale entre les sÃ©ries




# Analyse par rapport aux donnÃ©es d'entrÃ©e {.tabset}

## Fosberg Fire Weather Index (FFWI)


```{r FFWI_input_temperature}
### plotting temperatures within chosen range ###

date_debut <- as.Date("01/06/2020","%d/%m/%Y")
date_fin <- as.Date("31/12/2021","%d/%m/%Y")

ggplot(data = graph_T,
       mapping = aes(x = as.Date(DATE, origin="1970-01-01"), y =T, color =T, xmin = date_debut,xmax=date_fin)) +
  geom_point() +
  scale_color_gradient(guide="none", low="green", high="red") +
  labs(x = "Date", y = "Temperatures") +
  geom_point(data = graph_ffwi %>% filter(as.Date(DATE, origin="1970-01-01") %in% as.Date.character(Incendies_filtered$Alerte,format="%d/%m/%Y %H:%M", origin="1970-01-01")),
             pch=16, size=2, colour="black")

quant = 0.95

FFWI_Index_omit <- na.omit(FFwi_values)

FFWI_Index_omit_reverse <- FFWI_Index_omit
FFWI_Index_omit_reverse$FFwi <- FFWI_Index_omit_reverse$FFwi *-1

min_FFWI_Index_omit_reverse <- min(FFWI_Index_omit_reverse$FFwi)

FFWI_Index_omit_reverse$FFwi <- FFWI_Index_omit_reverse$FFwi - min_FFWI_Index_omit_reverse +1

extremal_correlation_input_output(FFWI_Index_omit_reverse$T, FFWI_Index_omit_reverse$FFwi,quant)

```


````{r FFWI_input_Humidité}

### plotting humidty within chosen range ###

ggplot(data = graph_U,
       mapping = aes(x = as.Date(DATE, origin="1970-01-01"), y = U, color = U, xmin = date_debut,xmax=date_fin)) +
  geom_point() +
  scale_color_gradient(guide="none", low="red", high="green") +
  labs(x = "Date", y = "Humidité") +
  geom_point(data = graph_ffwi %>% filter(as.Date(DATE, origin="1970-01-01") %in% as.Date.character(Incendies_filtered$Alerte,format="%d/%m/%Y %H:%M", origin="1970-01-01")),
             pch=16, size=2, colour="black")

extremal_correlation_input_output(U_complet$U,FFwi_values$FFwi,quant)

````


## FWI Canadien

## Angstrom Index

Nous allons commencer par analyser la sensibilitÃ© de cet indice par rapport Ã  la tempÃ©rature.
Afin d'avoir des extrÃªmes qui correspondent, nous inversons les valeurs de l'indice (Ã©tant donnÃ© que de base, une valeur faible indique un potentiel plus Ã©levÃ© d'incendie).

```` {r angstrom_input_temperature, warning=FALSE}
### plotting temperatures within chosen range ###

ggplot(data = graph_angstrom_index,
       mapping = aes(x = as.Date(DATE, origin="1970-01-01"), y = T, color = T, xmin = date_debut,xmax=date_fin)) +
  geom_point() +
  scale_color_gradient(guide="none", low="green", high="red") +
  labs(x = "Date", y = "Temperatures") +
  geom_point(data = graph_angstrom_index %>% filter(as.Date(DATE, origin="1970-01-01") %in% as.Date.character(Incendies_filtered$Alerte,format="%d/%m/%Y %H:%M", origin="1970-01-01")),
             pch=16, size=2, colour="black")

quant = 0.95

Angstrom_Index_omit <- na.omit(Angstrom_Index)

Angstrom_Index_omit_reverse <- Angstrom_Index_omit
Angstrom_Index_omit_reverse$ANGSTROM_INDEX <- Angstrom_Index_omit_reverse$ANGSTROM_INDEX *-1
min_Angstrom_Index_omit_reverse <- min(Angstrom_Index_omit_reverse$ANGSTROM_INDEX)
Angstrom_Index_omit_reverse$ANGSTROM_INDEX <- Angstrom_Index_omit_reverse$ANGSTROM_INDEX - min_Angstrom_Index_omit_reverse +1

extremal_correlation_input_output(Angstrom_Index_omit_reverse$T, Angstrom_Index_omit_reverse$ANGSTROM_INDEX,quant)

````
Pour Ã©tudier la sensibilitÃ© vis-Ã -vis de l'humiditÃ©, nous n'utilisons pas les valeurs inversÃ©es de l'indice car nous voulons vÃ©rifier une corrÃ©lation inversÃ©e : lorsque l'humiditÃ© est trÃ¨s Ã©levÃ©e, il est cohÃ©rent d'attendre un indice indiquant un risque moins Ã©levÃ© d'incendies, et donc une valeur Ã©levÃ©e.

````{r angstrom_input_humidity, warning=FALSE}
### plotting humidty within chosen range ###

ggplot(data = graph_angstrom_index,
       mapping = aes(x = as.Date(DATE, origin="1970-01-01"), y = U, color = U, xmin = date_debut,xmax=date_fin)) +
  geom_point() +
  scale_color_gradient(guide="none", low="red", high="green") +
  labs(x = "Date", y = "Temperatures") +
  geom_point(data = graph_angstrom_index %>% filter(as.Date(DATE, origin="1970-01-01") %in% as.Date.character(Incendies_filtered$Alerte,format="%d/%m/%Y %H:%M", origin="1970-01-01")),
             pch=16, size=2, colour="black")

extremal_correlation_input_output(Angstrom_Index_omit$U,Angstrom_Index_omit$ANGSTROM_INDEX,quant)

````
Nous trouvons une corrÃ©lation inversÃ©e plus Ã©levÃ©e que la corrÃ©lation avec la tempÃ©rature, ce qui permet de conclure que l'indice Angstrom est lÃ©gÃ¨rement plus sensible Ã  la sÃ©cheresse qu'Ã  la tempÃ©rature.

## MacArthur Grassland Mark 5 Index
# Conclusion